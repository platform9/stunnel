--- stunnel-5.56/src/client.c	2019-11-11 12:05:09.000000000 -0800
+++ stunnel-5.56-platform9/src/client.c	2020-07-09 18:14:58.624771795 -0700
@@ -902,6 +902,7 @@
                 c->ssl_ptr-=(size_t)num;
                 memset(c->ssl_buff+c->ssl_ptr, 0, (size_t)num); /* paranoia */
                 c->sock_bytes+=(size_t)num;
+                s_log(LOG_NOTICE, "wrote %ld byte(s) to socket", num);
                 watchdog=0; /* reset the watchdog */
             }
         }
@@ -922,6 +923,7 @@
                 break; /* do not reset the watchdog */
             default:
                 c->sock_ptr+=(size_t)num;
+                s_log(LOG_NOTICE, "read %ld byte(s) from socket", num);
                 watchdog=0; /* reset the watchdog */
             }
         }
@@ -950,6 +952,7 @@
                 c->sock_ptr-=(size_t)num;
                 memset(c->sock_buff+c->sock_ptr, 0, (size_t)num); /* paranoia */
                 c->ssl_bytes+=(size_t)num;
+                s_log(LOG_NOTICE, "wrote %ld byte(s) to TLS", num);
                 watchdog=0; /* reset the watchdog */
                 break;
             case SSL_ERROR_WANT_WRITE: /* buffered data? */
@@ -1007,6 +1010,7 @@
                     break; /* do not reset the watchdog */
                 }
                 c->ssl_ptr+=(size_t)num;
+                s_log(LOG_NOTICE, "read %ld byte(s) from TLS", num);
                 watchdog=0; /* reset the watchdog */
                 break;
             case SSL_ERROR_WANT_WRITE:
@@ -1470,6 +1474,7 @@
     SOCKET fd;
     unsigned idx_start, idx_try;
 
+    s_log(LOG_NOTICE, "connect_remote() called");
     connect_setup(c);
     switch(c->connect_addr.num) {
     case 0:
@@ -1485,6 +1490,7 @@
     /* try to connect each host from the list */
     for(idx_try=0; idx_try<c->connect_addr.num; idx_try++) {
         c->idx=(idx_start+idx_try)%c->connect_addr.num;
+        s_log(LOG_NOTICE, "connect_remote() c->idx: %d", c->idx);
         if(!connect_init(c, c->connect_addr.addr[c->idx].sa.sa_family) &&
                 !s_connect(c, &c->connect_addr.addr[c->idx],
                     addr_len(&c->connect_addr.addr[c->idx]))) {
@@ -1594,10 +1600,14 @@
         return;
     }
 
-    /* check if the address was already set in protocol negotiations */
-    /* used by the following protocols: CONNECT, SOCKS */
-    if(c->connect_addr.num)
-        return;
+    /* Platform9 CORE-956: don't reuse cached addresses */
+    if(c->connect_addr.num) {
+        s_log(LOG_NOTICE, "Clearing cached address(es)");
+        str_free(c->connect_addr.addr);
+        addrlist_clear(&c->connect_addr, 0);
+    } else {
+        s_log(LOG_NOTICE, "Resolving new address(es)");
+    }
 
     /* transparent destination */
     if(c->opt->option.transparent_dst) {
--- stunnel-5.56/src/resolver.c	2019-05-15 12:35:16.000000000 -0700
+++ stunnel-5.56-platform9/src/resolver.c	2020-07-09 18:53:12.792973061 -0700
@@ -247,6 +247,7 @@
     for(;;) {
         res=NULL;
         err=getaddrinfo(host_name, port_name, &hints, &res);
+        s_log(LOG_NOTICE, "getaddrinfo returned %d", err);
         if(!err) /* success */
             break;
         if(err==EAI_SERVICE) {
@@ -285,9 +286,12 @@
     /* append the newly resolved addresses to addr_list->addr */
     addr_list->addr=str_realloc_detached(addr_list->addr,
         (addr_list->num+num)*sizeof(SOCKADDR_UNION));
-    for(cur=res; cur; cur=cur->ai_next)
+    for(cur=res; cur; cur=cur->ai_next) {
+        char *dst = s_ntop((SOCKADDR_UNION*)cur->ai_addr, (size_t)cur->ai_addrlen);
+        s_log(LOG_INFO, "hostport2addrlist: new resolved address: %s", dst);
         memcpy(&addr_list->addr[(addr_list->num)++], cur->ai_addr,
             (size_t)cur->ai_addrlen);
+    }
 
     freeaddrinfo(res);
     return num; /* ok - return the number of new addresses */
@@ -311,9 +315,11 @@
 unsigned addrlist_dup(SOCKADDR_LIST *dst, const SOCKADDR_LIST *src) {
     memcpy(dst, src, sizeof(SOCKADDR_LIST));
     if(src->num) { /* already resolved */
+        s_log(LOG_NOTICE, "addlist_dup: already resolved");
         dst->addr=str_alloc_detached(src->num*sizeof(SOCKADDR_UNION));
         memcpy(dst->addr, src->addr, src->num*sizeof(SOCKADDR_UNION));
     } else { /* delayed resolver */
+        s_log(LOG_NOTICE, "addlist_dup: resolving");
         addrlist_resolve(dst);
     }
     return dst->num;
